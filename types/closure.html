<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>闭包类型 - Rust语言参考手册</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/reference-ce12791d.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-4a49bb37.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-99e7fd87.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust语言参考手册</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/zhiming-wu/rust-reference-zh_cn/" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <div class="rule" id="r-type.closure"><a class="rule-link" href="#r-type.closure" title="type.closure"><span>[type<wbr>.closure]</span></a>
</div>

<h1 id="闭包类型"><a class="header" href="#闭包类型">闭包类型</a></h1>
<div class="rule" id="r-type.closure.intro"><a class="rule-link" href="#r-type.closure.intro" title="type.closure.intro"><span>[type<wbr>.closure<wbr>.intro]</span></a>
</div>

<p><a href="../expressions/closure-expr.html">闭包表达式</a> 产生一个具有唯一的、匿名的且无法写出的类型的闭包值。
一个闭包类型大约等同于一个包含捕获值的结构体。
例如，以下闭包：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Point { x: i32, y: i32 }
struct Rectangle { left_top: Point, right_bottom: Point }

fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!("{}", g());
}

let mut rect = Rectangle {
    left_top: Point { x: 1, y: 1 },
    right_bottom: Point { x: 0, y: 0 }
};

let c = || {
    rect.left_top.x += 1;
    rect.right_bottom.x += 1;
    format!("{:?}", rect.left_top)
};
f(c); // 打印 "Point { x: 2, y: 1 }"。
<span class="boring">}</span></code></pre>
<p>生成一个大致如下的闭包类型：</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">// 注意：这并非准确的转换方式，仅用于说明。

struct Closure&lt;'a&gt; {
    left_top : &amp;'a mut Point,
    right_bottom_x : &amp;'a mut i32,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.left_top.x += 1;
        *self.right_bottom_x += 1;
        format!("{:?}", self.left_top)
    }
}</code></pre>
<p>使得对 <code>f</code> 的调用就像这样：</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{ left_top: &amp;mut rect.left_top, right_bottom_x: &amp;mut rect.right_bottom.x });</code></pre>
<div class="rule" id="r-type.closure.capture"><a class="rule-link" href="#r-type.closure.capture" title="type.closure.capture"><span>[type<wbr>.closure<wbr>.capture]</span></a>
</div>

<h2 id="捕获模式"><a class="header" href="#捕获模式">捕获模式</a></h2>
<div class="rule" id="r-type.closure.capture.intro"><a class="rule-link" href="#r-type.closure.capture.intro" title="type.closure.capture.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.intro]</span></a>
</div>

<p>一个 <em>捕获模式</em> 决定了环境中的 <a href="../expressions.html#位置表达式和值表达式">位置表达式</a> 是如何被借用或移动到闭包中的。
捕获模式有：</p>
<ol>
<li>不可变借用 (<code>ImmBorrow</code>) — 位置表达式作为 <a href="pointer.html#references--and-mut">共享引用</a> 被捕获。</li>
<li>唯一不可变借用 (<code>UniqueImmBorrow</code>) — 类似于不可变借用，但必须是唯一的，如 <a href="#unique-immutable-borrows-in-captures">下文</a> 所述。</li>
<li>可变借用 (<code>MutBorrow</code>) — 位置表达式作为 <a href="pointer.html#mutable-references-mut">可变引用</a> 被捕获。</li>
<li>移动 (<code>ByValue</code>) — 位置表达式通过 <a href="../expressions.html#moved-and-copied-types">移动值</a> 到闭包中而被捕获。</li>
</ol>
<div class="rule" id="r-type.closure.capture.precedence"><a class="rule-link" href="#r-type.closure.capture.precedence" title="type.closure.capture.precedence"><span>[type<wbr>.closure<wbr>.capture<wbr>.precedence]</span></a>
</div>

<p>来自环境的位置表达式按与捕获值在闭包体内的使用方式相兼容的第一种模式进行捕获。
该模式不受闭包周围代码的影响，例如相关变量或字段的生命周期，或者闭包本身的生命周期。</p>
<div class="rule" id="r-type.closure.capture.copy"><a class="rule-link" href="#r-type.closure.capture.copy" title="type.closure.capture.copy"><span>[type<wbr>.closure<wbr>.capture<wbr>.copy]</span></a>
</div>

<h3 id="copy值"><a class="header" href="#copy值"><code>Copy</code>值</a></h3>
<p>实现了 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> 的值如果被移动到闭包中，将以 <code>ImmBorrow</code> 模式捕获。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [0; 1024];
let c = || {
    let y = x; // x 通过 ImmBorrow 捕获
};
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.async.input"><a class="rule-link" href="#r-type.closure.async.input" title="type.closure.async.input"><span>[type<wbr>.closure<wbr>.async<wbr>.input]</span></a>
</div>

<h3 id="异步输入捕获"><a class="header" href="#异步输入捕获">异步输入捕获</a></h3>
<p>异步闭包总是捕获所有输入参数，无论它们是否在闭包体中使用。</p>
<h2 id="捕获精度"><a class="header" href="#捕获精度">捕获精度</a></h2>
<div class="rule" id="r-type.closure.capture.precision.capture-path"><a class="rule-link" href="#r-type.closure.capture.precision.capture-path" title="type.closure.capture.precision.capture-path"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.capture-path]</span></a>
</div>

<p>一个 <em>捕获路径</em> 是一个序列，起始于环境中的变量，后跟该变量的零个或多个位置投影。</p>
<div class="rule" id="r-type.closure.capture.precision.place-projection"><a class="rule-link" href="#r-type.closure.capture.precision.place-projection" title="type.closure.capture.precision.place-projection"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.place-projection]</span></a>
</div>

<p>一个 <em>位置投影</em> 是对变量应用的 <a href="../expressions/field-expr.html">字段访问</a>、<a href="../expressions/tuple-expr.html#tuple-indexing-expressions">元组索引</a>、<a href="../expressions/operator-expr.html#the-dereference-operator">解引用</a>（以及自动解引用）、<a href="../expressions/array-expr.html#array-and-slice-indexing-expressions">数组或切片索引</a> 表达式或 <a href="../patterns.html#r-patterns.destructure">模式解构</a>。</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>注意</p>

<p>在 <code>rustc</code> 中，模式解构会被脱糖为一系列解引用以及字段或元素访问。</p>
</blockquote>
</div>

<div class="rule" id="r-type.closure.capture.precision.intro"><a class="rule-link" href="#r-type.closure.capture.precision.intro" title="type.closure.capture.precision.intro"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.intro]</span></a>
</div>

<p>闭包借用或移动捕获路径，该路径可能会根据下述规则被截断。</p>
<p>例如：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    f1: (i32, i32),
}
let s = SomeStruct { f1: (1, 2) };

let c = || {
    let x = s.f1.1; // s.f1.1 通过 ImmBorrow 捕获
};
c();
<span class="boring">}</span></code></pre>
<p>这里的捕获路径是局部变量 <code>s</code> ，后跟一个字段访问 <code>.f1</code> ，然后是一个元组索引 <code>.1</code> 。
这个闭包捕获了 <code>s.f1.1</code> 的不可变借用。</p>
<div class="rule" id="r-type.closure.capture.precision.shared-prefix"><a class="rule-link" href="#r-type.closure.capture.precision.shared-prefix" title="type.closure.capture.precision.shared-prefix"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.shared-prefix]</span></a>
</div>

<h3 id="共享前缀"><a class="header" href="#共享前缀">共享前缀</a></h3>
<p>在捕获路径及其祖先路径都被闭包捕获的情况下，祖先路径以两者中最高的捕获模式捕获， <code>CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)</code> ，使用严格弱序：</p>
<p><code>ImmBorrow &lt; UniqueImmBorrow &lt; MutBorrow &lt; ByValue</code></p>
<p>注意这可能需要递归应用。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在这个例子中，有三个具有共享祖先的不同捕获路径：
<span class="boring">fn move_value&lt;T&gt;(_: T){}
</span>let s = String::from("S");
let t = (s, String::from("T"));
let mut u = (t, String::from("U"));

let c = || {
    println!("{:?}", u); // u 通过 ImmBorrow 捕获
    u.1.truncate(0); // u.0 通过 MutBorrow 捕获
    move_value(u.0.0); // u.0.0 通过 ByValue 捕获
};
c();
<span class="boring">}</span></code></pre>
<p>总的来说，这个闭包将通过 <code>ByValue</code> 捕获 <code>u</code> 。</p>
<div class="rule" id="r-type.closure.capture.precision.dereference-shared"><a class="rule-link" href="#r-type.closure.capture.precision.dereference-shared" title="type.closure.capture.precision.dereference-shared"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.dereference-shared]</span></a>
</div>

<h3 id="最右侧共享引用解引用截断"><a class="header" href="#最右侧共享引用解引用截断">最右侧共享引用解引用截断</a></h3>
<p>如果解引用应用于共享引用，捕获路径将在捕获路径中最右侧的解引用处截断。</p>
<p>允许这种截断是因为通过共享引用读取的字段将始终通过共享引用或副本读取。
当额外的精度在借用检查的角度下没有任何益处时，这有助于减小捕获的大小。</p>
<p>之所以是 <em>最右侧</em> 解引用，是为了帮助避免产生比必要生命周期更短的生命周期。
考虑以下示例：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Int(i32);
struct B&lt;'a&gt;(&amp;'a i32);

struct MyStruct&lt;'a&gt; {
   a: &amp;'static Int,
   b: B&lt;'a&gt;,
}

fn foo&lt;'a, 'b&gt;(m: &amp;'a MyStruct&lt;'b&gt;) -&gt; impl FnMut() + 'static {
    let c = || drop(&amp;m.a.0);
    c
}
<span class="boring">}</span></code></pre>
<p>如果要捕获 <code>m</code> ，那么闭包将不再能比 <code>'static</code> 存活得更久，因为 <code>m</code> 被限制在 <code>'a</code> 。相反，它通过 <code>ImmBorrow</code> 捕获 <code>(*(*m).a)</code> 。</p>
<div class="rule" id="r-type.closure.capture.precision.wildcard"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard" title="type.closure.capture.precision.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard]</span></a>
</div>

<h3 id="通配符模式绑定"><a class="header" href="#通配符模式绑定">通配符模式绑定</a></h3>
<div class="rule" id="r-type.closure.capture.precision.wildcard.reads"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.reads" title="type.closure.capture.precision.wildcard.reads"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.reads]</span></a>
</div>

<p>闭包仅捕获需要读取的数据。使用 <a href="../patterns.html#wildcard-pattern">通配符模式</a> 绑定一个值不会读取该值，因此该位置不会被捕获。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 一个非 `Copy` 类型。
let x = S;
let c = || {
    let _ = x;  // 不捕获 `x`。
};
let c = || match x {
    _ =&gt; (), // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.destructuring"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.destructuring" title="type.closure.capture.precision.wildcard.destructuring"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.destructuring]</span></a>
</div>

<p>解构元组、结构体和单 变体 枚举本身不会导致读取或位置被捕获。</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>注意</p>

<p>来自其他 crate 的带有 <a href="../attributes/type_system.html#r-attributes.type-system.non_exhaustive"><code>#[non_exhaustive]</code></a> 标记的枚举总是被视为具有多个 变体 。参见 <em><a href="closure.html#r-type.closure.capture.precision.discriminants.non_exhaustive">type.closure.capture.precision.discriminants.non_exhaustive</a></em>。</p>
</blockquote>
</div>

<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 一个非 `Copy` 类型。

// 解构元组不会导致读取或捕获。
let x = (S,);
let c = || {
    let (..) = x; // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();

// 解构类单元结构体不会导致读取或捕获。
let x = S;
let c = || {
    let S = x; // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();

// 解构结构体不会导致读取或捕获。
struct W&lt;T&gt;(T);
let x = W(S);
let c = || {
    let W(..) = x; // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();

// 解构单变体枚举不会导致读取或捕获。
enum E&lt;T&gt; { V(T) }
let x = E::V(S);
let c = || {
    let E::V(..) = x; // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.fields"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.fields" title="type.closure.capture.precision.wildcard.fields"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.fields]</span></a>
</div>

<p>与 <a href="../patterns.html#grammar-RestPattern">RestPattern</a> (<code>..</code>) 或 <a href="../patterns.html#grammar-StructPatternEtCetera">StructPatternEtCetera</a> (也是 <code>..</code>) 匹配的字段不会被读取，且这些字段不会被捕获。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 一个非 `Copy` 类型。
let x = (S, S);
let c = || {
    let (x0, ..) = x;  // 通过 `ByValue` 捕获 `x.0`。
};
// 只有第一个元组字段被闭包捕获。
x.1; // OK： `x.1` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.array-slice"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.array-slice" title="type.closure.capture.precision.wildcard.array-slice"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.array-slice]</span></a>
</div>

<p>不支持对数组和切片的部分捕获；即使使用通配符模式匹配、索引或子切片，整个切片或数组也总是会被捕获。</p>
<pre class="playground"><code class="language-rust compile_fail E0382 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 一个非 `Copy` 类型。
let mut x = [S, S];
let c = || {
    let [x0, _] = x; // 通过 `ByValue` 捕获全部 `x`。
};
let _ = &amp;mut x[1]; // 错误：借用了已移动的值。
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.wildcard.initialized"><a class="rule-link" href="#r-type.closure.capture.precision.wildcard.initialized" title="type.closure.capture.precision.wildcard.initialized"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.wildcard<wbr>.initialized]</span></a>
</div>

<p>与通配符匹配的值仍必须已初始化。</p>
<pre class="playground"><code class="language-rust compile_fail E0381 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8;
let c = || {
    let _ = x; // 错误：绑定 `x` 未初始化。
};
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.discriminants"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants" title="type.closure.capture.precision.discriminants"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants]</span></a>
</div>

<h3 id="为读取判别式而捕获"><a class="header" href="#为读取判别式而捕获">为读取判别式而捕获</a></h3>
<div class="rule" id="r-type.closure.capture.precision.discriminants.reads"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants.reads" title="type.closure.capture.precision.discriminants.reads"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants<wbr>.reads]</span></a>
</div>

<p>如果模式匹配读取了判别式，则包含该判别式的位置将通过 <code>ImmBorrow</code> 被捕获。</p>
<div class="rule" id="r-type.closure.capture.precision.discriminants.multiple-variant"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants.multiple-variant" title="type.closure.capture.precision.discriminants.multiple-variant"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants<wbr>.multiple-variant]</span></a>
</div>

<p>与具有多于一个 变体 的枚举的 变体 进行匹配会读取判别式，从而通过 <code>ImmBorrow</code> 捕获该位置。</p>
<pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 一个非 `Copy` 类型。
let mut x = (Some(S), S);
let c = || match x {
    (None, _) =&gt; (),
//   ^^^^
// 此模式需要读取判别式，这导致 `x.0` 被 `ImmBorrow` 捕获。
    _ =&gt; (),
};
let _ = &amp;mut x.0; // 错误：不能将 `x.0` 借用为可变。
//           ^^^
// 闭包仍然存活，所以 `x.0` 在这里仍然被不可变借用。
c();
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S; // 一个非 `Copy` 类型。
</span><span class="boring">let x = (Some(S), S);
</span>let c = || match x { // 通过 `ImmBorrow` 捕获 `x.0`。
    (None, _) =&gt; (),
    _ =&gt; (),
};
// 尽管 `x.0` 因判别式读取而被捕获，但 `x.1` 未被捕获。
x.1; // OK： `x.1` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.discriminants.single-variant"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants.single-variant" title="type.closure.capture.precision.discriminants.single-variant"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants<wbr>.single-variant]</span></a>
</div>

<p>与单 变体 枚举的唯一 变体 进行匹配不会读取判别式，也不会捕获该位置。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E&lt;T&gt; { V(T) } // 一个单变体枚举。
let x = E::V(());
let c = || {
    let E::V(_) = x; // 不捕获 `x`。
};
x; // OK： `x` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.discriminants.non_exhaustive"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants.non_exhaustive" title="type.closure.capture.precision.discriminants.non_exhaustive"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants<wbr>.non_exhaustive]</span></a>
</div>

<p>如果 <a href="../attributes/type_system.html#r-attributes.type-system.non_exhaustive"><code>#[non_exhaustive]</code></a> 应用于在外部 crate 中定义的枚举，则出于决定是否发生读取的目的，该枚举被视为具有多个 变体 ，即使它实际上只有一个 变体 。</p>
<div class="rule" id="r-type.closure.capture.precision.discriminants.uninhabited-variants"><a class="rule-link" href="#r-type.closure.capture.precision.discriminants.uninhabited-variants" title="type.closure.capture.precision.discriminants.uninhabited-variants"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.discriminants<wbr>.uninhabited-variants]</span></a>
</div>

<p>即使除被匹配的 变体 外的所有 变体 都是未入驻的，使得模式 <a href="../patterns.html#r-patterns.refutable">不可驳回</a>，如果本来会读取判别式，则判别式仍会被读取。</p>
<pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}
let mut x = Ok::&lt;_, Empty&gt;(42);
let c = || {
    let Ok(_) = x; // 通过 `ImmBorrow` 捕获 `x`。
};
let _ = &amp;mut x; // 错误：不能将 `x` 借用为可变。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.range-patterns"><a class="rule-link" href="#r-type.closure.capture.precision.range-patterns" title="type.closure.capture.precision.range-patterns"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.range-patterns]</span></a>
</div>

<h3 id="捕获与范围模式"><a class="header" href="#捕获与范围模式">捕获与范围模式</a></h3>
<div class="rule" id="r-type.closure.capture.precision.range-patterns.reads"><a class="rule-link" href="#r-type.closure.capture.precision.range-patterns.reads" title="type.closure.capture.precision.range-patterns.reads"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.range-patterns<wbr>.reads]</span></a>
</div>

<p>与 <a href="../patterns.html#r-patterns.range">范围模式</a> 进行匹配会读取被匹配的位置，即使范围包含了该类型的所有可能值，并会通过 <code>ImmBorrow</code> 捕获该位置。</p>
<pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 0u8;
let c = || {
    let 0..=u8::MAX = x; // 通过 `ImmBorrow` 捕获 `x`。
};
let _ = &amp;mut x; // 错误：不能将 `x` 借用为可变。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.slice-patterns"><a class="rule-link" href="#r-type.closure.capture.precision.slice-patterns" title="type.closure.capture.precision.slice-patterns"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.slice-patterns]</span></a>
</div>

<h3 id="捕获与切片模式"><a class="header" href="#捕获与切片模式">捕获与切片模式</a></h3>
<div class="rule" id="r-type.closure.capture.precision.slice-patterns.slices"><a class="rule-link" href="#r-type.closure.capture.precision.slice-patterns.slices" title="type.closure.capture.precision.slice-patterns.slices"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.slice-patterns<wbr>.slices]</span></a>
</div>

<p>将切片与除仅包含单个 <a href="../patterns.html#r-patterns.rest">剩余模式</a>（即 <code>[..]</code> ）以外的 <a href="../patterns.html#r-patterns.slice">切片模式</a> 进行匹配，将被视为对切片长度的读取，并通过 <code>ImmBorrow</code> 捕获切片。</p>
<pre class="playground"><code class="language-rust compile_fail E0502 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // 通过 `ImmBorrow` 捕获 `*x`。
    &amp;mut [] =&gt; (),
//       ^^
// 这匹配一个长度恰好为零的切片。为了知道被检查对象是否匹配，
// 必须读取长度，从而导致切片被捕获。
    _ =&gt; (),
};
let _ = &amp;mut *x; // 错误：不能将 `*x` 借用为可变。
c();
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;mut [u8] = &amp;mut [];
let c = || match x { // 不捕获 `*x`。
    [..] =&gt; (),
//   ^^ 剩余模式。
};
let _ = &amp;mut *x; // OK： `*x` 可以在这里被借用。
c();
<span class="boring">}</span></code></pre>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>注意</p>

<p>也许令人惊讶的是，尽管长度包含在切片的（宽） <em>指针</em> 中，但被视为读取并被捕获的是 <em>被指物</em> （切片）的位置。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    // 闭包存活时间超过 `'l`，因为它捕获了 `**x`。如果
    // 它捕获的是 `*x`，它将存活得不够长，
    // 无法满足 `impl Fn() + 'l` 界限。
    || match *x { // 通过 `ImmBorrow` 捕获 `**x`。
        &amp;[] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre>
<p>这样，该行为与在被检查对象中解引用到切片是一致的。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;'l: 's, 's&gt;(x: &amp;'s mut &amp;'l [u8]) -&gt; impl Fn() + 'l {
    || match **x { // 通过 `ImmBorrow` 捕获 `**x`。
        [] =&gt; (),
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre>
<p>有关详细信息，请参见 <a href="https://github.com/rust-lang/rust/pull/138961">Rust PR #138961</a>。</p>
</blockquote>
</div>

<div class="rule" id="r-type.closure.capture.precision.slice-patterns.arrays"><a class="rule-link" href="#r-type.closure.capture.precision.slice-patterns.arrays" title="type.closure.capture.precision.slice-patterns.arrays"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.slice-patterns<wbr>.arrays]</span></a>
</div>

<p>由于数组的长度由其类型固定，因此将数组与切片模式匹配本身不会捕获该位置。</p>
<pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: [u8; 1] = [0];
let c = || match x { // 不捕获 `x`。
    [_] =&gt; (), // 长度是固定的。
};
x; // OK： `x` 可以在这里被移动。
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.move-dereference"><a class="rule-link" href="#r-type.closure.capture.precision.move-dereference" title="type.closure.capture.precision.move-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.move-dereference]</span></a>
</div>

<h3 id="在移动语境中捕获引用"><a class="header" href="#在移动语境中捕获引用">在移动语境中捕获引用</a></h3>
<p>由于不允许从引用中移出字段， <code>move</code> 闭包将仅捕获捕获路径的前缀，该前缀一直延伸到但不包括引用的第一次解引用。
引用本身将被移动到闭包中。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::from("foo"), String::from("bar"));
let t_mut_ref = &amp;mut t;
let mut c = move || {
    t_mut_ref.0.push_str("123"); // 通过 ByValue 捕获 `t_mut_ref`
};
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.raw-pointer-dereference"><a class="rule-link" href="#r-type.closure.capture.precision.raw-pointer-dereference" title="type.closure.capture.precision.raw-pointer-dereference"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.raw-pointer-dereference]</span></a>
</div>

<h3 id="裸指针解引用"><a class="header" href="#裸指针解引用">裸指针解引用</a></h3>
<p>由于解引用裸指针是 <code>unsafe</code> 的，闭包将仅捕获捕获路径的前缀，该前缀一直延伸到但不包括裸指针的第一次解引用。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let t = T(String::from("foo"), String::from("bar"));
let t_ptr = &amp;t as *const T;

let c = || unsafe {
    println!("{}", (*t_ptr).0); // 通过 ImmBorrow 捕获 `t_ptr`
};
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.union"><a class="rule-link" href="#r-type.closure.capture.precision.union" title="type.closure.capture.precision.union"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.union]</span></a>
</div>

<h3 id="联合体-字段"><a class="header" href="#联合体-字段">联合体 字段</a></h3>
<p>由于访问 联合体 字段是 <code>unsafe</code> 的，闭包将仅捕获捕获路径的前缀，该前缀一直延伸到 联合体 本身。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union U {
    a: (i32, i32),
    b: bool,
}
let u = U { a: (123, 456) };

let c = || {
    let x = unsafe { u.a.0 }; // 通过 ByValue 捕获 `u`
};
c();

// 这也包括写入字段。
let mut u = U { a: (123, 456) };

let mut c = || {
    u.b = true; // 通过 MutBorrow 捕获 `u`
};
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.unaligned"><a class="rule-link" href="#r-type.closure.capture.precision.unaligned" title="type.closure.capture.precision.unaligned"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.unaligned]</span></a>
</div>

<h3 id="对未对齐struct的引用"><a class="header" href="#对未对齐struct的引用">对未对齐<code>struct</code>的引用</a></h3>
<p>由于创建对结构体中未对齐字段的引用是 <a href="../behavior-considered-undefined.html">未定义行为</a> ，
闭包将仅捕获捕获路径的前缀，该前缀一直延伸到但不包括对使用 <a href="../type-layout.html#the-alignment-modifiers"> <code>packed</code> 表示</a> 的结构体的第一次字段访问。
这包括所有字段，甚至是那些已对齐的字段，以防止将来结构体中的任何字段发生更改时产生兼容性问题。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(i32, i32);

let t = T(2, 5);
let c = || {
    let a = t.0; // 通过 ImmBorrow 捕获 `t`
};
// 从 `t` 中复制是可以的。
let (a, b) = (t.0, t.1);
c();
<span class="boring">}</span></code></pre>
<p>类似地，获取未对齐字段的地址也会捕获整个结构体：</p>
<pre class="playground"><code class="language-rust compile_fail E0505 edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // 通过 ImmBorrow 捕获 `t`
};
let a = t.0; // 错误：无法移出 `t.0` ，因为它已被借用
c();
<span class="boring">}</span></code></pre>
<p>但如果它不是 packed 的，上述代码就可以工作，因为它能精确地捕获字段：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct T(String, String);

let mut t = T(String::new(), String::new());
let c = || {
    let a = std::ptr::addr_of!(t.1); // 通过 ImmBorrow 捕获 `t.1`
};
// 这里的移动是允许的。
let a = t.0;
c();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.box-deref"><a class="rule-link" href="#r-type.closure.capture.precision.box-deref" title="type.closure.capture.precision.box-deref"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-deref]</span></a>
</div>

<h3 id="box与其他deref实现"><a class="header" href="#box与其他deref实现"><code>Box</code>与其他<code>Deref</code>实现</a></h3>
<p><a href="../special-types-and-traits.html#boxt"><code>Box</code></a> 的 <a href="../special-types-and-traits.html#deref-and-derefmut"><code>Deref</code></a> 特型 实现与其他 <code>Deref</code> 实现受到的待遇不同，因为它被视为一个特殊的实体。</p>
<p>例如，让我们看看涉及 <code>Rc</code> 和 <code>Box</code> 的例子。 <code>*rc</code> 被脱糖为对 <code>Rc</code> 上定义的特型方法 <code>deref</code> 的调用，但由于 <code>*box</code> 受到不同待遇，因此可以对 <code>Box</code> 的内容进行精确捕获。</p>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.not-moved"><a class="rule-link" href="#r-type.closure.capture.precision.box-non-move.not-moved" title="type.closure.capture.precision.box-non-move.not-moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.not-moved]</span></a>
</div>

<h4 id="具有非move闭包的box"><a class="header" href="#具有非move闭包的box">具有非<code>move</code>闭包的<code>Box</code></a></h4>
<p>在非 <code>move</code> 闭包中，如果 <code>Box</code> 的内容没有被移动到闭包体中，则 <code>Box</code> 的内容会被精确捕获。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = &amp;(*b).0; // 通过 ImmBorrow 捕获 `(*b).0`
};
c_box();

// 将 `Box` 与另一个实现了 Deref 的类型进行对比：
let r = std::rc::Rc::new(S(String::new()));
let c_rc = || {
    let x = &amp;(*r).0; // 通过 ImmBorrow 捕获 `r`
};
c_rc();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.box-non-move.moved"><a class="rule-link" href="#r-type.closure.capture.precision.box-non-move.moved" title="type.closure.capture.precision.box-non-move.moved"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-non-move<wbr>.moved]</span></a>
</div>

<p>然而，如果 <code>Box</code> 的内容被移动到闭包中，那么该 box 会被整体捕获。这样做是为了尽量减少需要移动到闭包中的数据量。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这与上面的例子相同，除了闭包
// 移动值而不是获取其引用。

struct S(String);

let b = Box::new(S(String::new()));
let c_box = || {
    let x = (*b).0; // 通过 ByValue 捕获 `b`
};
c_box();
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.box-move.read"><a class="rule-link" href="#r-type.closure.capture.precision.box-move.read" title="type.closure.capture.precision.box-move.read"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.box-move<wbr>.read]</span></a>
</div>

<h4 id="具有move闭包的box"><a class="header" href="#具有move闭包的box">具有move闭包的<code>Box</code></a></h4>
<p>类似于在非 <code>move</code> 闭包中移动 <code>Box</code> 的内容，在 <code>move</code> 闭包中读取 <code>Box</code> 的内容将整体捕获 <code>Box</code> 。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S(i32);

let b = Box::new(S(10));
let c_box = move || {
    let x = (*b).0; // 通过 ByValue 捕获 `b`
};
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.unique-immutable"><a class="rule-link" href="#r-type.closure.unique-immutable" title="type.closure.unique-immutable"><span>[type<wbr>.closure<wbr>.unique-immutable]</span></a>
</div>

<h2 id="捕获中的唯一不可变借用"><a class="header" href="#捕获中的唯一不可变借用">捕获中的唯一不可变借用</a></h2>
<p>捕获可以通过一种称为 <em>唯一不可变借用</em> 的特殊借用发生，这种借用在语言的其他地方无法使用，也无法显式写出。它发生在修改可变引用的引用物时，如下例所示：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
let mut c = || {
    // x 的一个 ImmBorrow 和一个 MutBorrow。
    let a = &amp;x;
    *x = true; // `x` 通过 UniqueImmBorrow 捕获
};
// 下面这行是一个错误：
// let y = &amp;x;
c();
// 然而，下面这样是可以的。
let z = &amp;x;
<span class="boring">}</span></code></pre>
<p>在这种情况下，由于 <code>x</code> 不是 <code>mut</code> ，所以无法以可变方式借用 <code>x</code> 。但与此同时，不可变地借用 <code>x</code> 会使赋值操作非法，因为 <code>&amp; &amp;mut</code> 引用可能不是唯一的，因此无法安全地用于修改值。所以使用了唯一不可变借用：它不可变地借用 <code>x</code> ，但像可变借用一样，它必须是唯一的。</p>
<p>在上面的示例中，取消对 <code>y</code> 的声明的注释将产生错误，因为它会违反闭包对 <code>x</code> 借用的唯一性； z 的声明是有效的，因为闭包的生命周期在块结束时已过期，释放了借用。</p>
<div class="rule" id="r-type.closure.call"><a class="rule-link" href="#r-type.closure.call" title="type.closure.call"><span>[type<wbr>.closure<wbr>.call]</span></a>
</div>

<h2 id="调用特型与隐式类型转换"><a class="header" href="#调用特型与隐式类型转换">调用特型与隐式类型转换</a></h2>
<div class="rule" id="r-type.closure.call.intro"><a class="rule-link" href="#r-type.closure.call.intro" title="type.closure.call.intro"><span>[type<wbr>.closure<wbr>.call<wbr>.intro]</span></a>
</div>

<p>闭包类型都实现了 <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> ，表示它们可以通过消耗闭包的所有权来调用一次。此外，一些闭包还实现了更具体的调用 特型 ：</p>
<div class="rule" id="r-type.closure.call.fn-mut"><a class="rule-link" href="#r-type.closure.call.fn-mut" title="type.closure.call.fn-mut"><span>[type<wbr>.closure<wbr>.call<wbr>.fn-mut]</span></a>
</div>

<ul>
<li>不从任何捕获变量中移出的闭包实现了 <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> ，表示它可以通过可变引用调用。</li>
</ul>
<div class="rule" id="r-type.closure.call.fn"><a class="rule-link" href="#r-type.closure.call.fn" title="type.closure.call.fn"><span>[type<wbr>.closure<wbr>.call<wbr>.fn]</span></a>
</div>

<ul>
<li>不修改或从任何捕获变量中移出的闭包实现了 <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> ，表示它可以通过共享引用调用。</li>
</ul>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>注意</p>

<p><code>move</code> 闭包仍可能实现 <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 或 <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> ，即使它们通过移动捕获变量。这是因为由闭包类型实现的 特型 是由闭包对捕获值的操作决定的，而不是由它如何捕获它们决定的。</p>
</blockquote>
</div>

<div class="rule" id="r-type.closure.non-capturing"><a class="rule-link" href="#r-type.closure.non-capturing" title="type.closure.non-capturing"><span>[type<wbr>.closure<wbr>.non-capturing]</span></a>
</div>

<p><em>非捕获闭包</em> 是不从其环境中捕获任何内容的闭包。非异步、非捕获的闭包可以被 隐式类型转换 为具有匹配签名的函数指针（例如， <code>fn()</code> ）。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.async.traits"><a class="rule-link" href="#r-type.closure.async.traits" title="type.closure.async.traits"><span>[type<wbr>.closure<wbr>.async<wbr>.traits]</span></a>
</div>

<h3 id="异步闭包特型"><a class="header" href="#异步闭包特型">异步闭包特型</a></h3>
<div class="rule" id="r-type.closure.async.traits.fn-family"><a class="rule-link" href="#r-type.closure.async.traits.fn-family" title="type.closure.async.traits.fn-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.fn-family]</span></a>
</div>

<p>异步闭包在是否实现 <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 或 <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 方面有进一步的限制。</p>
<p>异步闭包返回的 <a href="../../core/future/future/trait.Future.html"><code>Future</code></a> 具有与闭包类似的捕获特性。它根据位置表达式的使用方式从异步闭包中捕获它们。如果异步闭包具有以下任一属性，则称其向其 <a href="../../core/future/future/trait.Future.html"><code>Future</code></a> <em>借出 (lending)</em> ：</p>
<ul>
<li><code>Future</code> 包含一个可变捕获。</li>
<li>异步闭包通过值捕获，除非该值是通过解引用投影访问的。</li>
</ul>
<p>如果异步闭包向其 <code>Future</code> 借出，则 <em>不</em> 实现 <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 和 <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 。 <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> 始终会被实现。</p>
<blockquote>
<p><strong>示例</strong>：可变捕获的第一种情况可以通过以下方式说明：</p>
<pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl FnMut() -&gt; Fut) {}

fn f() {
    let mut x = 1i32;
    let c = async || {
        x = 2;  // x 通过 MutBorrow 捕获
    };
    takes_callback(c);  // 错误：异步闭包未实现 `FnMut`
}
<span class="boring">}</span></code></pre>
<p>普通值捕获的第二种情况可以通过以下方式说明：</p>
<pre class="playground"><code class="language-rust compile_fail edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = x + 2;  // x 通过 ByValue 捕获
    };
    takes_callback(c);  // 错误：异步闭包未实现 `Fn`
}
<span class="boring">}</span></code></pre>
<p>第二种情况的例外可以通过使用解引用来说明，这确实允许实现 <code>Fn</code> 和 <code>FnMut</code> ：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_callback&lt;Fut: Future&gt;(c: impl Fn() -&gt; Fut) {}

fn f() {
    let x = &amp;1i32;
    let c = async move || {
        let a = *x + 2;
    };
    takes_callback(c);  // OK：实现了 `Fn`
}
<span class="boring">}</span></code></pre>
</blockquote>
<div class="rule" id="r-type.closure.async.traits.async-family"><a class="rule-link" href="#r-type.closure.async.traits.async-family" title="type.closure.async.traits.async-family"><span>[type<wbr>.closure<wbr>.async<wbr>.traits<wbr>.async-family]</span></a>
</div>

<p>异步闭包实现 <a href="../../core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a> 、 <a href="../../core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a> 和 <a href="../../core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a> 的方式，与普通闭包实现 <a href="../../core/ops/function/trait.Fn.html"><code>Fn</code></a> 、 <a href="../../core/ops/function/trait.FnMut.html"><code>FnMut</code></a> 和 <a href="../../core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> 的方式类似；也就是说，取决于其体中对捕获变量的使用。</p>
<div class="rule" id="r-type.closure.traits"><a class="rule-link" href="#r-type.closure.traits" title="type.closure.traits"><span>[type<wbr>.closure<wbr>.traits]</span></a>
</div>

<h3 id="其他特型"><a class="header" href="#其他特型">其他特型</a></h3>
<div class="rule" id="r-type.closure.traits.intro"><a class="rule-link" href="#r-type.closure.traits.intro" title="type.closure.traits.intro"><span>[type<wbr>.closure<wbr>.traits<wbr>.intro]</span></a>
</div>

<p>所有闭包类型都实现 <a href="../special-types-and-traits.html#sized"><code>Sized</code></a> 。此外，如果闭包存储的捕获类型允许，闭包类型还会实现以下 特型 ：</p>
<ul>
<li><a href="../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<div class="rule" id="r-type.closure.traits.behavior"><a class="rule-link" href="#r-type.closure.traits.behavior" title="type.closure.traits.behavior"><span>[type<wbr>.closure<wbr>.traits<wbr>.behavior]</span></a>
</div>

<p><a href="../special-types-and-traits.html#send"><code>Send</code></a> 和 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> 的规则与普通结构体类型的规则一致，而 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> 和 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> 的行为就像是 <a href="../attributes/derive.html">派生</a> 的。对于 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> ，捕获值的克隆顺序未指定。</p>
<p>由于捕获通常是通过引用进行的，因此会产生以下一般规则：</p>
<ul>
<li>如果所有捕获的值都是 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> ，则闭包是 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> 。</li>
<li>如果所有通过非唯一不可变引用捕获的值都是 <a href="../special-types-and-traits.html#sync"><code>Sync</code></a> ，且所有通过唯一不可变或可变引用、复制或移动捕获的值都是 <a href="../special-types-and-traits.html#send"><code>Send</code></a> ，则闭包是 <a href="../special-types-and-traits.html#send"><code>Send</code></a> 。</li>
<li>如果闭包未通过唯一不可变或可变引用捕获任何值，且它通过复制或移动捕获的所有值分别实现了 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> 或 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> ，则闭包是 <a href="../special-types-and-traits.html#clone"><code>Clone</code></a> 或 <a href="../special-types-and-traits.html#copy"><code>Copy</code></a> 。</li>
</ul>
<div class="rule" id="r-type.closure.drop-order"><a class="rule-link" href="#r-type.closure.drop-order" title="type.closure.drop-order"><span>[type<wbr>.closure<wbr>.drop-order]</span></a>
</div>

<h2 id="丢弃顺序"><a class="header" href="#丢弃顺序">丢弃顺序</a></h2>
<p>如果闭包通过值捕获复合类型（如结构体、元组和枚举）的一个字段，则该字段的生命周期现在将与闭包绑定。因此，复合类型的互不相交字段可能会在不同时间被丢弃。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar")); // --+
    { //                                               |
        let c = || { // ----------------------------+  |
            // tuple.0 被捕获到闭包中                |  |
            drop(tuple.0); //                       |  |
        }; //                                       |  |
    } // 'c' 和 'tuple.0' 在这里被丢弃 -------------+  |
} // tuple.1 在这里被丢弃 -----------------------------+
<span class="boring">}</span></code></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.entirety"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.entirety" title="type.closure.capture.precision.edition2018.entirety"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.entirety]</span></a>
</div>

<h2 id="2018版次及更早版本"><a class="header" href="#2018版次及更早版本">2018版次及更早版本</a></h2>
<h3 id="闭包类型差异"><a class="header" href="#闭包类型差异">闭包类型差异</a></h3>
<p>在2018版次及更早版本中，闭包总是整体捕获变量，而没有精确的捕获路径。这意味着对于 <a href="#closure-types">闭包类型</a> 章节中使用的示例，生成的闭包类型将如下所示：</p>
<!-- ignore: simplified -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    rect : &amp;'a mut Rectangle,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    extern "rust-call" fn call_once(self, args: ()) -&gt; String {
        self.rect.left_top.x += 1;
        self.rect.right_bottom.x += 1;
        format!("{:?}", self.rect.left_top)
    }
}</code></pre>
<p>并且对 <code>f</code> 的调用将如下工作：</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure { rect: rect });</code></pre>
<div class="rule" id="r-type.closure.capture.precision.edition2018.composite"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.composite" title="type.closure.capture.precision.edition2018.composite"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.composite]</span></a>
</div>

<h3 id="捕获精度差异"><a class="header" href="#捕获精度差异">捕获精度差异</a></h3>
<p>复合类型（如结构体、元组和枚举）总是被整体捕获，而不是按单个字段捕获。因此，可能需要借用到局部变量中以便捕获单个字段：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}</span></code></pre>
<p>相反，如果闭包直接使用 <code>self.vec</code> ，那么它将尝试通过可变引用捕获 <code>self</code> 。但由于 <code>self.set</code> 已经被借用用于迭代，代码将无法编译。</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.move"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.move" title="type.closure.capture.precision.edition2018.move"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.move]</span></a>
</div>

<p>如果使用了 <code>move</code> 关键字，那么所有的捕获都是通过移动进行的，或者对于 <code>Copy</code> 类型通过复制进行，无论借用是否可行。 <code>move</code> 关键字通常用于允许闭包存活时间超过捕获的值，例如闭包被返回或用于派生新线程的情况。</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.wildcard"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.wildcard" title="type.closure.capture.precision.edition2018.wildcard"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.wildcard]</span></a>
</div>

<p>无论数据是否会被闭包读取（即在通配符模式的情况下），如果在闭包内提到了闭包外定义的变量，该变量都将被整体捕获。</p>
<div class="rule" id="r-type.closure.capture.precision.edition2018.drop-order"><a class="rule-link" href="#r-type.closure.capture.precision.edition2018.drop-order" title="type.closure.capture.precision.edition2018.drop-order"><span>[type<wbr>.closure<wbr>.capture<wbr>.precision<wbr>.edition2018<wbr>.drop-order]</span></a>
</div>

<h3 id="丢弃顺序差异"><a class="header" href="#丢弃顺序差异">丢弃顺序差异</a></h3>
<p>由于复合类型是被整体捕获的，因此通过值捕获其中一种复合类型的闭包将在闭包被丢弃的同时丢弃整个捕获的变量。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let tuple =
      (String::from("foo"), String::from("bar"));
    {
        let c = || { // --------------------------+
            // tuple 被捕获到闭包中                  |
            drop(tuple.0); //                     |
        }; //                                     |
    } // 'c' 和 'tuple' 在这里被丢弃 --------------+
}
<span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../types/function-item.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../types/pointer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../types/function-item.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../types/pointer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/reference-da60281b.js"></script>



    </div>
    </body>
</html>
